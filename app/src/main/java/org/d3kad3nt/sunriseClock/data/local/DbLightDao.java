package org.d3kad3nt.sunriseClock.data.local;

import androidx.lifecycle.LiveData;
import androidx.room.Dao;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Query;
import androidx.room.Transaction;
import androidx.room.Update;

import org.d3kad3nt.sunriseClock.data.model.light.DbLight;
import org.d3kad3nt.sunriseClock.util.LogUtil;

import java.util.List;

@Dao
public interface DbLightDao {

    /**
     * Insert light object into the database (create) or update existing light object. Case 1:
     * Insert if neither lightId (primary key) nor (endpointId and endpointLightId) are found inside
     * the database. Case 2: Update if lightId (primary key) is given in the light object. A light
     * with this lightId must already exist inside the database. Case 3: Update if endpointId and
     * endpointLightId are given in the light object. A light with this endpointId and
     * endpointLightId must already exist inside the database.
     *
     * @param obj The DbLight object with the lightId OR (endpointId and endpointLightId) set.
     */
    @Transaction
    default void upsert(DbLight obj) {
        // Case 1
        long rowId = save(obj);
        if (rowId != -1L) {
            LogUtil.d(
                    "Inserted DbLight (row id: %d) with endpointId %d and endpointLightId: %s",
                    rowId, obj.getEndpointId(), obj.getEndpointLightId());
            return;
        }

        // Case 2
        // Primary key found in light object.
        if (obj.getLightId() != 0L) {
            int rowsUpdated = updateUsingPrimaryKey(obj);
            if (rowsUpdated >= 1) {
                LogUtil.d(
                        "%d rows updated by room. Updated DbLight with lightId: %d",
                        rowsUpdated, obj.getLightId());
            } else if (rowsUpdated == 0) {
                LogUtil.w(
                        "0 rows updated by room. This could mean that the primary key (lightId: %d) "
                                + "could not be found in the database table.",
                        obj.getLightId());
            }
        }
        // Case 3
        // Primary key NOT found in light object. This can happen if (all) light objects are
        // retrieved
        // from the
        // remote endpoint.
        // Rhe lightId primary key is autogenerated by room, therefore it is not known to the remote
        // endpoint.
        else if (obj.getEndpointId() != 0L && !(obj.getEndpointLightId().equals(""))) {
            int rowsUpdated =
                    updateUsingEndpointIdAndEndpointLightId(
                            obj.getEndpointId(),
                            obj.getEndpointLightId(),
                            obj.getName(),
                            obj.getIsSwitchable(),
                            obj.getIsOn(),
                            obj.getIsDimmable(),
                            obj.getBrightness(),
                            obj.getIsTemperaturable(),
                            obj.getColorTemperature(),
                            obj.getIsColorable(),
                            obj.getColor());
            LogUtil.d(
                    "%d rows updated by room. Updated DbLight with endpointId: %d"
                            + " and endpointLightId: %s",
                    rowsUpdated, obj.getEndpointId(), obj.getEndpointLightId());
        } else {
            LogUtil.w(
                    "Neither lightId nor (endpointId and endpointLightId) were set. No update could be performed by "
                            + "room!");
        }
    }

    /**
     * Insert the light into the database. If there is a conflict on insert, the light is not
     * inserted and a special value is returned.
     *
     * @param obj The DbLight object with the endpointId and endpointLightId set.
     * @return -1 for rows that are not inserted (will ignore the row if there is a conflict), else
     *     the row id for the newly inserted item.
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    // An Insert DAO method that returns the inserted rows ids will return -1 for rows that are not
    // inserted since
    // this strategy will ignore the row if there is a conflict.
    long save(DbLight obj);

    /**
     * Use lightId primary key for SQL update. Room uses the primary key to match passed entity
     * instances to rows in the database. If there is no row with the same primary key, Room makes
     * no changes.
     *
     * @param obj The DbLight object with the primary key set.
     * @return Number of rows that were updated successfully.
     */
    @Update()
    int updateUsingPrimaryKey(DbLight obj);

    /**
     * Use endpointId and endpointLightId for (manual) SQL update statement.
     *
     * @return Number of rows that were updated successfully.
     */
    @Query(
            "UPDATE "
                    + DbLight.TABLENAME
                    + " SET name = :friendlyName, is_switchable = :switchable, is_on = :on, "
                    + "is_dimmable  = :dimmable, brightness = :brightness, is_temperaturable = :temperaturable, "
                    + "colortemperature = :colorTemperature, is_colorable = :colorable, color = :color WHERE endpoint_id = "
                    + ":endpointId AND endpoint_light_id = :endpointLightId")
    int updateUsingEndpointIdAndEndpointLightId(
            long endpointId,
            String endpointLightId,
            String friendlyName,
            boolean switchable,
            boolean on,
            boolean dimmable,
            int brightness,
            boolean temperaturable,
            int colorTemperature,
            boolean colorable,
            int color);

    @Delete()
    void delete(DbLight obj);

    @Query("SELECT * FROM " + DbLight.TABLENAME + " WHERE light_id = :lightId")
    LiveData<DbLight> load(long lightId);

    @Query("SELECT * FROM " + DbLight.TABLENAME + " WHERE endpoint_id = :endpointId")
    LiveData<List<DbLight>> loadAllForEndpoint(long endpointId);
}
