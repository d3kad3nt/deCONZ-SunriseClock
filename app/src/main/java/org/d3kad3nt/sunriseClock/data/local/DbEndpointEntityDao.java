package org.d3kad3nt.sunriseClock.data.local;

import android.util.Log;

import androidx.annotation.NonNull;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Transaction;
import androidx.room.Update;

import org.d3kad3nt.sunriseClock.data.model.DbEndpointEntity;

public interface DbEndpointEntityDao <T extends DbEndpointEntity> {

    String TAG = "DbEndpointEntityDao";

    /**
     * Insert an endpoint entity (e.g. group or light) into the database (create) or update existing entity. Case 1:
     * Insert if neither id (primary key) nor (endpointId and endpointEntityId) are found inside the database. Case 2:
     * Update if id (primary key) is given in the object. An entity with this id must already exist inside the
     * database. Case 3: Update if endpointId and endpointEntityId are given in the object. An entity with this
     * endpointId and endpointEntityId must already exist inside the database.
     *
     * @param dbEndpointEntity The dbEndpointEntity with the id OR (endpointId and endpointEntityId) set.
     */
    @Transaction
    default void upsert(T dbEndpointEntity) {
        // Case 1
        long rowId = save(dbEndpointEntity);
        if (rowId != -1L) {
            Log.d(TAG, "Inserted into table " + dbEndpointEntity.getTABLENAME() + " (row id: " + rowId +
                ") with endpointId " + dbEndpointEntity.getEndpointId() + " and endpointEntityId: " +
                dbEndpointEntity.getEndpointEntityId());
            return;
        }

        // Case 2
        // Primary key found in endpoint entity.
        if (dbEndpointEntity.getId() != 0L) {
            int rowsUpdated = updateUsingPrimaryKey(dbEndpointEntity);
            if (rowsUpdated >= 1) {
                Log.d(TAG, "Updated " + rowsUpdated + " rows. Updated table " + dbEndpointEntity.getTABLENAME() +
                    " with primary key: " + dbEndpointEntity.getId());
            } else if (rowsUpdated == 0) {
                Log.w(TAG, "Updated 0 rows. This could mean that the primary key (id: " + dbEndpointEntity.getId() +
                    ") could not be found in the database table.");
            }
        }
        // Case 3
        // Primary key NOT found in endpoint entity. This can happen if (all) entities are retrieved from the
        // remote endpoint.
        // The primary key (id) is autogenerated by room, therefore it is not known to the remote endpoint.
        else if (dbEndpointEntity.getEndpointId() != 0L && !(dbEndpointEntity.getEndpointEntityId().equals(""))) {
            int rowsUpdated = updateUsingEndpointIdAndEndpointEntityId(dbEndpointEntity);
            Log.d(TAG, "Updated " + rowsUpdated + " rows. Updated table " + dbEndpointEntity.getTABLENAME() +
                " with endpointId: " + dbEndpointEntity.getEndpointId() + " and endpointEntityId: " +
                dbEndpointEntity.getEndpointEntityId());
        } else {
            Log.w(TAG,
                "Neither id nor (endpointId and endpointEntityId) were set. No update or insert could be performed" +
                    " by room!");
        }
    }

    /**
     * Use endpointId and endpointEntityId for manual SQL update statement. Overwritten by DAO interfaces.
     *
     * @param dbEndpointEntity The endpoint entity with the endpointId and endpointEntityId set.
     * @return Number of rows that were updated successfully.
     */
    int updateUsingEndpointIdAndEndpointEntityId(@NonNull T dbEndpointEntity);

    /**
     * Insert the entity into the database. If there is a conflict on insert, the entity is not inserted and a special
     * value is returned.
     *
     * @param dbEndpointEntity The endpoint entity with the endpointId and endpointEntityId set.
     * @return -1 for rows that are not inserted (will ignore the row if there is a conflict), else the row id for the
     * newly inserted item.
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    // An Insert DAO method that returns the inserted rows ids will return -1 for rows that are not inserted since
    // this strategy will ignore the row if there is a conflict.
    long save(T dbEndpointEntity);

    /**
     * Use primary key (id) for SQL update. Room uses the primary key to match passed entity instances to rows in the
     * database. If there is no row with the same primary key, Room makes no changes.
     *
     * @param dbEndpointEntity The dbEndpointEntity with the primary key set.
     * @return Number of rows that were updated successfully.
     */
    @Update()
    int updateUsingPrimaryKey(T dbEndpointEntity);

    @Delete()
    void delete(T dbEndpointEntity);
}
