package org.d3kad3nt.sunriseClock.backend.data.local;

import androidx.annotation.NonNull;
import androidx.room.Delete;
import androidx.room.Insert;
import androidx.room.OnConflictStrategy;
import androidx.room.Transaction;
import androidx.room.Update;
import java.util.List;
import org.d3kad3nt.sunriseClock.backend.data.model.DbEndpointEntity;
import org.d3kad3nt.sunriseClock.util.LogUtil;

public interface DbEndpointEntityDao<T extends DbEndpointEntity> {

    /**
     * Insert an endpoint entity (e.g. group or light) into the database (create) or update existing entity.
     * <li>Case 1: Insert if neither id (primary key) nor (endpointId and endpointEntityId, the composite primary key)
     *     are found inside the database.
     * <li>Case 2: Update if id (primary key) is given in the object. An entity with this id must already exist inside
     *     the database.
     * <li>Case 3: Update if endpointId and endpointEntityId are given in the object. An entity with this endpointId and
     *     endpointEntityId must already exist inside the database.
     *
     * @param dbEndpointEntity The endpoint entity with the id OR (endpointId (see
     *     {@link DbEndpointEntity#getEndpointId()}) and endpointEntityId (see
     *     {@link DbEndpointEntity#getEndpointEntityId()}), the composite primary key) set.
     * @return The primary key of the inserted or updated endpoint entity.
     */
    @Transaction
    default long upsert(T dbEndpointEntity) {
        // Case 1
        long rowId = save(dbEndpointEntity);
        if (rowId != -1L) {
            LogUtil.d(
                    "Inserted into table %s with endpointId %d and endpointEntityId %s. This resulted in the "
                            + "primary key (id) to be set to %d.",
                    dbEndpointEntity.getTABLENAME(),
                    dbEndpointEntity.getEndpointId(),
                    dbEndpointEntity.getEndpointEntityId(),
                    rowId);
            // Per the SQLite specification the primary key (id) becomes an alias for the row id if
            // the table
            // declares an INTEGER PRIMARY KEY.
            return rowId;
        }

        // Case 2
        // Primary key found in endpoint entity.
        long dbEndpointEntityId = dbEndpointEntity.getId();
        if (dbEndpointEntityId != 0L) {
            int rowsUpdated = updateUsingPrimaryKey(dbEndpointEntity);
            if (rowsUpdated >= 1) {
                LogUtil.d(
                        "Updated %d rows. Updated table %s with primary key %s.",
                        rowsUpdated, dbEndpointEntity.getTABLENAME(), dbEndpointEntityId);
                return dbEndpointEntityId;
            } else if (rowsUpdated == 0) {
                LogUtil.w(
                        "Updated 0 rows. This could mean that the primary key %s could not be found in the "
                                + "%s table.",
                        dbEndpointEntityId, dbEndpointEntity.getTABLENAME());
                return 0;
            }
        }

        // Case 3
        // Primary key NOT found in endpoint entity. This can happen if (all) entities are retrieved
        // from the
        // remote endpoint for the first time.
        // The primary key (id) is autogenerated by room, therefore it is not known to the remote
        // endpoint.
        long endpointId = dbEndpointEntity.getEndpointId();
        String endpointEntityId = dbEndpointEntity.getEndpointEntityId();
        if (endpointId != 0L && !(endpointEntityId.isEmpty())) {
            int rowsUpdated = updateUsingEndpointIdAndEndpointEntityId(dbEndpointEntity);
            LogUtil.d(
                    "Updated %d rows. Updated table %s with endpointId %d and endpointEntityId %s.",
                    rowsUpdated, dbEndpointEntity.getTABLENAME(), endpointId, endpointEntityId);
            // Unfortunately Room does not support the RETURNING clause in SQLITE which could be
            // used to return the
            // primary key of the newly updated database entity. We have to resort to send another
            // SELECT query to
            // the database.
            // Todo: To improve performance we could implement two separate upsert() methods to only
            // return the
            //  primary key (id) when needed.
            long pk = getIdForEndpointIdAndEndpointEntityId(endpointId, endpointEntityId);
            LogUtil.v(
                    "This UPDATE operation led to a separate SELECT query on the %s table to get the primary key "
                            + "%d of the database entity.",
                    dbEndpointEntity.getTABLENAME(), pk);
            return pk;
        } else {
            LogUtil.w("Neither id nor (endpointId and endpointEntityId) were set. No update or insert could be "
                    + "performed by room!");
            return 0;
        }
    }

    /**
     * Insert multiple endpoint entities (e.g. groups or lights) into the database (create) or update existing entity.
     *
     * <p>See the {@link #upsert} method for details on insertion behaviour.
     *
     * @param dbEndpointEntities List of endpoint entities.
     */
    @Transaction
    default void upsert(List<T> dbEndpointEntities) {
        dbEndpointEntities.forEach(t -> upsert(t));
    }

    /**
     * Use endpointId and endpointEntityId for manual SQL update statement. Overwritten by DAO interfaces.
     *
     * @param dbEndpointEntity The endpoint entity with the endpointId (see {@link DbEndpointEntity#getEndpointId()})
     *     and endpointEntityId (see {@link DbEndpointEntity#getEndpointEntityId()}) set.
     * @return Number of rows that were updated successfully.
     */
    int updateUsingEndpointIdAndEndpointEntityId(@NonNull T dbEndpointEntity);

    /**
     * Get the primary key (id) for the dbEndpointEntity identified by the given composite key (endpointId and
     * endpointEntityId). Overwritten by DAO interfaces.
     *
     * @param endpointId See {@link DbEndpointEntity#getEndpointId()}.
     * @param endpointEntityId See {@link DbEndpointEntity#getEndpointEntityId()}.
     * @return The primary key for the dbEndpointEntity identified by the given composite key. 0 if the primary could
     *     not be found.
     */
    long getIdForEndpointIdAndEndpointEntityId(long endpointId, String endpointEntityId);

    /**
     * Insert the entity into the database. If there is a conflict on insert, the entity is not inserted and a special
     * value is returned.
     *
     * @param dbEndpointEntity The endpoint entity with the {@link DbEndpointEntity#getEndpointId()} and
     *     {@link DbEndpointEntity#getEndpointEntityId()} set.
     * @return -1 for rows that are not inserted (will ignore the row if there is a conflict), else the row id for the
     *     newly inserted item.
     */
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    // An Insert DAO method that returns the inserted rows ids will return -1 for rows that are not
    // inserted since this strategy will ignore the row if there is a conflict.
    long save(T dbEndpointEntity);

    /**
     * Use primary key (id) for SQL update. Room uses the primary key to match passed entity instances to rows in the
     * database. If there is no row with the same primary key, Room makes no changes.
     *
     * @param dbEndpointEntity The dbEndpointEntity with the primary key set.
     * @return Number of rows that were updated successfully.
     */
    @Update()
    int updateUsingPrimaryKey(T dbEndpointEntity);

    /** @noinspection unused */
    @Delete()
    void delete(T dbEndpointEntity);
}
